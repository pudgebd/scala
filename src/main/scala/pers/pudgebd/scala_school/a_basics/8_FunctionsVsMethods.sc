//class C {
//    var acc = 0
//
//    def minc = {
//        acc += 1
//    }
//    val finc = { () => acc + 1 }
//}
//
//val c = new C
//c.minc
//c.finc

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

//定义一个方法
def m(x: Int): Int = 2 * x

//定义一个函数
val f = (x: Int) => 2 * x

//方法不能作为最终表达式出现
//无参方法可以作为最终表达式出现，其实这属于方法调用，scala规定无参函数的调用可以省略括号
//m

//函数可以作为最终表达式出现；得到函数自身，不会发生函数调用
f

//----------------------------------------------------------------------
//----------------------------------------------------------------------

val myList = List(3, 56, 1, 4, 72)
// map()参数是一个函数
myList.map((x) => 2 * x)

//尝试给map()函提供一个方法作为参数
def methodMulti4(x: Int) = 4 * x
myList.map(methodMulti4)

//这是因为，如果期望出现函数的地方我们提供了一个方法的话，该方法就会自动被转换成函数。该行为被称为ETA expansion。
//这样的话使用函数将会变得简单很多。你可以按照下面的代码验证该行为：

//期望出现函数的地方，我们可以使用方法
val f3: (Int) => Int = methodMulti4
//不期望出现函数的地方，方法并不会自动转换成函数
//val v3 = m4

//利用这种自动转换，我们可以写出很简洁的代码，如下面这样
//10.<被解释成obj.method，即整形的<的方法，所以该表达式是一个方法，会被解释成函数
myList.filter(10.<)

//因为在scala中操作符被解释称方法
//前缀操作符：op obj 被解释称obj.op
//中缀操作符：obj1 op obj2被解释称obj1.op(obj2)
//后缀操作符：obj op被解释称obj.op
//你可以写成10.<而不是10<

//如何强制把一个方法变成函数
//可以在方法名后面加一个下划线强制变成函数，部分应用函数
val f4 = methodMulti4 _


//----------------------------------------------------------------------
//----------------------------------------------------------------------


//传名参数是一个方法
//传名参数实质是一个没有参数列表的方法。正是因此你才可以使用名字调用而不用添加()
def m1(x: => Int) = List(x, x)

import util.Random

val r = new Random()
////因为方法被调用了两次，所以两个值不相等
m1(r.nextInt())

//如果你在方法体部分缓存了传名参数（函数），那么你就缓存了值（因为x函数被调用了一次）
//把传名参数代表的函数缓存起来

def m2(x: => Int) = {
    val y = x; List(y, y)
}

//能否在函数体部分引用传名参数所代表的方法呢，是可以的(缓存的是传名参数所代表的方法)。
def m3(x: => Int) = {
    val y = x _; List(y(), y())
}
m3(r.nextInt)