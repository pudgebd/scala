//类型参数边界
//在用类型参数定义了一个抽象类Set[A]后，在实现中要用到比较(<>)，但是不能确定A的具体类型，因此不能直接使用。
// 一个解决办法就是对合法类型进行限制，对只含有方法<>的类型放行。在标准库里有一个特质Ordered[A]，用来表示可比较的类型。
// 现在可以强制要求这个类型为Ordered的子类型。可以通过给出一个上界(upper bound)的方式来解决这个问题：

////这样定义后，传入的A类型参数必须是Ordered[A]的子类型。也即，可以被比较。
trait Set[A <: Ordered[A]] {
    def incl(x: A): Set[A]
    def contains(x: A): Boolean
}


//先说说协变和逆变（实际上还有非变）。协变和逆变主要是用来解决参数化类型的泛化问题。由于参数化类型的参数（参数类型）是可变的，当两个参数化类型的参数是继承关系（可泛化），那被参数化的类型是否也可以泛化呢？Java中这种情况下是不可泛化的，然而Scala提供了三个选择，即协变、逆变和非变。下面说一下三种情况的含义，首先假设有参数化特征Queue，那它可以有如下三种定义。
//1）trait Queue[T] {}
//这是非变情况。这种情况下，当类型S是类型A的子类型，则Queue[S]不可认为是Queue[A]的子类型或父类型，这种情况是和Java一样的。
//
//2）trait Queue[+T] {}
//这是协变情况。这种情况下，当类型S是类型A的子类型，则Queue[S]也可以认为是Queue[A}的子类型，即Queue[S]可以泛化为Queue[A]。也就是被参数化类型的泛化方向与参数类型的方向是一致的，所以称为协变。
//
//3）trait Queue[-T] {}
//这是逆变情况。这种情况下，当类型S是类型A的子类型，则Queue[A]反过来可以认为是Queue[S}的子类型。也就是被参数化类型的泛化方向与参数类型的方向是相反的，所以称为逆变。




